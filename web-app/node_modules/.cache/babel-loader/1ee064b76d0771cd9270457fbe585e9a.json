{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = require(\"rxjs/operators\");\n/**\r\n * Branch out the source Observable values as a nested Observable with each\r\n * nested Observable emitting at most `windowSize` values.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * <img src=\"./img/windowCount.png\" width=\"100%\">\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits windows every `startWindowEvery`\r\n * items, each containing no more than `windowSize` items. When the source\r\n * Observable completes or encounters an error, the output Observable emits\r\n * the current window and propagates the notification from the source\r\n * Observable. If `startWindowEvery` is not provided, then new windows are\r\n * started immediately at the start of the source and when each window completes\r\n * with size `windowSize`.\r\n *\r\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.windowCount(3)\r\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\r\n *   .mergeAll(); // flatten the Observable-of-Observables\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.windowCount(2, 3)\r\n *   .mergeAll(); // flatten the Observable-of-Observables\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link window}\r\n * @see {@link windowTime}\r\n * @see {@link windowToggle}\r\n * @see {@link windowWhen}\r\n * @see {@link bufferCount}\r\n *\r\n * @param {number} windowSize The maximum number of values emitted by each\r\n * window.\r\n * @param {number} [startWindowEvery] Interval at which to start a new window.\r\n * For example if `startWindowEvery` is `2`, then a new window will be started\r\n * on every other value from the source. A new window is started at the\r\n * beginning of the source by default.\r\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\r\n * are Observable of values.\r\n * @method windowCount\r\n * @owner Observable\r\n */\n\n\nfunction windowCount(windowSize, startWindowEvery) {\n  if (startWindowEvery === void 0) {\n    startWindowEvery = 0;\n  }\n\n  return operators_1.windowCount(windowSize, startWindowEvery)(this);\n}\n\nexports.windowCount = windowCount;","map":null,"metadata":{},"sourceType":"script"}