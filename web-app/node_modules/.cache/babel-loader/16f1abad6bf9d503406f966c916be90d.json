{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = require(\"rxjs/operators\");\n/**\r\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\r\n * the source terminates on complete, error or unsubscribe.\r\n *\r\n * <span class=\"informal\">Ensure a given function will be called when a stream ends, no matter why it ended.</span>\r\n *\r\n * `finally` method accepts as a single parameter a function. This function does not accept any parameters and\r\n * should not return anything. It will be called whenever source Observable completes, errors or is unsubscribed,\r\n * which makes it good candidate to perform any necessary clean up or side effects when Observable terminates,\r\n * no matter how or why it terminated.\r\n *\r\n * Observable returned by `finally` will simply mirror source Observable - each time it is subscribed, source\r\n * Observable will be subscribed underneath.\r\n *\r\n * Note that behavior of `finally` will be repeated per every subscription, so if resulting Observable has\r\n * many subscribers, function passed to `finally` might be potentially called multiple times.\r\n *\r\n * Remember also that `finally` differs quite a lot from passing complete or error handler to {@link subscribe}. It will\r\n * return an Observable which can be further chained, while `subscribe` returns Subscription, basically ending Observable\r\n * chain. Function passed to `finally` will be called also when consumer of resulting Observable unsubscribes from it,\r\n * while handlers passed to `subscribe` will not (even complete handler). But most importantly, `finally` does not start\r\n * an execution of source Observable, like `subscribe` does, allowing you to set up all necessary hooks before\r\n * passing Observable further, even without specific knowledge how or when it will be used.\r\n *\r\n *\r\n * @example <caption>Call finally after complete notification</caption>\r\n * Rx.Observable.of(1, 2, 3)\r\n * .finally(() => console.log('I was finalized!'))\r\n * .map(x => x * 2) // `finally` returns an Observable, so we still can chain operators.\r\n * .subscribe(\r\n *   val => console.log(val),\r\n *   err => {},\r\n *   () => console.log('I completed!')\r\n * );\r\n *\r\n * // Logs:\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // \"I completed!\"\r\n * // \"I was finalized!\"\r\n *\r\n *\r\n *\r\n * @example <caption>Call finally after consumer unsubscribes</caption>\r\n * const o = Rx.Observable.interval(1000)\r\n * .finally(() => console.log('Timer stopped'));\r\n *\r\n * const subscription = o.subscribe(\r\n *   val => console.log(val),\r\n *   err => {},\r\n *   () => console.log('Complete!') // Will not be called, since complete handler\r\n * );                               // does not react to unsubscription, just to\r\n *                                  // complete notification sent by the Observable itself.\r\n *\r\n * setTimeout(() => subscription.unsubscribe(), 2500);\r\n *\r\n * // Logs:\r\n * // 0 after 1s\r\n * // 1 after 2s\r\n * // \"Timer stopped\" after 2.5s\r\n *\r\n * @see {@link using}\r\n *\r\n * @param {function} callback Function to be called when source terminates (completes, errors or is unsubscribed).\r\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\r\n * @method finally\r\n * @name finally\r\n * @owner Observable\r\n */\n\n\nfunction _finally(callback) {\n  return operators_1.finalize(callback)(this);\n}\n\nexports._finally = _finally;","map":null,"metadata":{},"sourceType":"script"}