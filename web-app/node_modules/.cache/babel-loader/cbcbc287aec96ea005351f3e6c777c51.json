{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = require(\"rxjs/operators\");\n/**\r\n * Applies an accumulator function over the source Observable where the\r\n * accumulator function itself returns an Observable, then each intermediate\r\n * Observable returned is merged into the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\r\n * by the accumulator are merged into the outer Observable.</span>\r\n *\r\n * @example <caption>Count the number of click events</caption>\r\n * const click$ = Rx.Observable.fromEvent(document, 'click');\r\n * const one$ = click$.mapTo(1);\r\n * const seed = 0;\r\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\r\n * count$.subscribe(x => console.log(x));\r\n *\r\n * // Results:\r\n * 1\r\n * 2\r\n * 3\r\n * 4\r\n * // ...and so on for each click\r\n *\r\n * @param {function(acc: R, value: T): Observable<R>} accumulator\r\n * The accumulator function called on each source value.\r\n * @param seed The initial accumulation value.\r\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\r\n * input Observables being subscribed to concurrently.\r\n * @return {Observable<R>} An observable of the accumulated values.\r\n * @method mergeScan\r\n * @owner Observable\r\n */\n\n\nfunction mergeScan(accumulator, seed, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return operators_1.mergeScan(accumulator, seed, concurrent)(this);\n}\n\nexports.mergeScan = mergeScan;","map":null,"metadata":{},"sourceType":"script"}