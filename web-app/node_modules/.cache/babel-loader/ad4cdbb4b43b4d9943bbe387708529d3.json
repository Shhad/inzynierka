{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = require(\"rxjs\");\n/* tslint:enable:max-line-length */\n\n/**\r\n * Creates an output Observable which concurrently emits all values from every\r\n * given input Observable.\r\n *\r\n * <span class=\"informal\">Flattens multiple Observables together by blending\r\n * their values into one Observable.</span>\r\n *\r\n * <img src=\"./img/merge.png\" width=\"100%\">\r\n *\r\n * `merge` subscribes to each given input Observable (either the source or an\r\n * Observable given as argument), and simply forwards (without doing any\r\n * transformation) all the values from all the input Observables to the output\r\n * Observable. The output Observable only completes once all input Observables\r\n * have completed. Any error delivered by an input Observable will be immediately\r\n * emitted on the output Observable.\r\n *\r\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var timer = Rx.Observable.interval(1000);\r\n * var clicksOrTimer = clicks.merge(timer);\r\n * clicksOrTimer.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\r\n * var timer1 = Rx.Observable.interval(1000).take(10);\r\n * var timer2 = Rx.Observable.interval(2000).take(6);\r\n * var timer3 = Rx.Observable.interval(500).take(10);\r\n * var concurrent = 2; // the argument\r\n * var merged = timer1.merge(timer2, timer3, concurrent);\r\n * merged.subscribe(x => console.log(x));\r\n *\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeMapTo}\r\n * @see {@link mergeScan}\r\n *\r\n * @param {ObservableInput} other An input Observable to merge with the source\r\n * Observable. More than one input Observables may be given as argument.\r\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\r\n * Observables being subscribed to concurrently.\r\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\r\n * concurrency of input Observables.\r\n * @return {Observable} An Observable that emits items that are the result of\r\n * every input Observable.\r\n * @method merge\r\n * @owner Observable\r\n */\n\n\nfunction merge() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i] = arguments[_i];\n  }\n\n  return this.lift.call(rxjs_1.merge.apply(void 0, [this].concat(observables)));\n}\n\nexports.merge = merge;","map":null,"metadata":{},"sourceType":"script"}