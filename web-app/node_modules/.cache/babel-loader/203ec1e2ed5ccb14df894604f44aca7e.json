{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n/**\r\n * Emits a value from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent value from each burst of emissions.</span>\r\n *\r\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\r\n *\r\n * `debounceTime` delays values emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new value arrives on the source\r\n * Observable. This operator keeps track of the most recent value from the\r\n * source Observable, and emits that only when `dueTime` enough time has passed\r\n * without any other value appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous value will be dropped\r\n * and will not be emitted on the output Observable.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * value to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\r\n * managing timers.\r\n *\r\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.debounceTime(1000);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link delay}\r\n * @see {@link sampleTime}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} dueTime The timeout duration in milliseconds (or the time\r\n * unit determined internally by the optional `scheduler`) for the window of\r\n * time required to wait for emission silence before emitting the most recent\r\n * source value.\r\n * @param {Scheduler} [scheduler=asyncScheduler] The {@link SchedulerLike} to use for\r\n * managing the timers that handle the timeout for each value.\r\n * @return {Observable} An Observable that delays the emissions of the source\r\n * Observable by the specified `dueTime`, and may drop some values if they occur\r\n * too frequently.\r\n * @method debounceTime\r\n * @owner Observable\r\n */\n\n\nfunction debounceTime(dueTime, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = rxjs_1.asyncScheduler;\n  }\n\n  return operators_1.debounceTime(dueTime, scheduler)(this);\n}\n\nexports.debounceTime = debounceTime;","map":null,"metadata":{},"sourceType":"script"}