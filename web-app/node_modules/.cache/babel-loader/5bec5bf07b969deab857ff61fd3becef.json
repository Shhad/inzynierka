{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = require(\"rxjs/operators\");\n/**\r\n * Converts an Observable of {@link Notification} objects into the emissions\r\n * that they represent.\r\n *\r\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\r\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\r\n *\r\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\r\n *\r\n * `dematerialize` is assumed to operate an Observable that only emits\r\n * {@link Notification} objects as `next` emissions, and does not emit any\r\n * `error`. Such Observable is the output of a `materialize` operation. Those\r\n * notifications are then unwrapped using the metadata they contain, and emitted\r\n * as `next`, `error`, and `complete` on the output Observable.\r\n *\r\n * Use this operator in conjunction with {@link materialize}.\r\n *\r\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\r\n * var notifA = new Rx.Notification('N', 'A');\r\n * var notifB = new Rx.Notification('N', 'B');\r\n * var notifE = new Rx.Notification('E', void 0,\r\n *   new TypeError('x.toUpperCase is not a function')\r\n * );\r\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\r\n * var upperCase = materialized.dematerialize();\r\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\r\n *\r\n * // Results in:\r\n * // A\r\n * // B\r\n * // TypeError: x.toUpperCase is not a function\r\n *\r\n * @see {@link Notification}\r\n * @see {@link materialize}\r\n *\r\n * @return {Observable} An Observable that emits items and notifications\r\n * embedded in Notification objects emitted by the source Observable.\r\n * @method dematerialize\r\n * @owner Observable\r\n */\n\n\nfunction dematerialize() {\n  return operators_1.dematerialize()(this);\n}\n\nexports.dematerialize = dematerialize;","map":null,"metadata":{},"sourceType":"script"}